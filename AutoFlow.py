"""
This script contains the AutoFlow system, which consists of the following parts:
- Virtual landscape (defined & generated by Components.py)
- Vehicle agent object definitions
- Multi-agent pathfinding algorithm

The distribution of EVs is based on https://www.iea.org/reports/global-ev-outlook-2023/executive-summary.
The number of vehicle agents to spawn in must be smaller than the (number of available coordinates * 2),
this is because currently vehicles are placed into random cell coordinates (which must be unique).

The following input variables are used to describe the virtual simualtion:
- LANDSCAPE_SIZE: a tuple describing the approximate dimensions of the landscape, see LandscapeComponents.py
- VEHICLE_COUNT: the exact number of vehicle agents to be spawned into the simulation
- AUTOFLOW_PERCENTAGE: the percentage of vehicle agents using AutoFlow

TODO: Refactor vehicle agents into a separate simulation script for different result comparisons
"""


#================ IMPORTS ================
from LandscapeComponents import *
from VehicleAgents import *

from TestHelper import *

from random import sample
from heapq import *
from math import ceil
#=========================================


#================ INPUTS =================
LANDSCAPE_SIZE = (5, 5)
LANDSCAPE_FEATURES = [
    (LandPlotDescriptor((2, 2), (1, 1)), 5)
]
LANDSCAPE_FILLER = LandPlotDescriptor((2, 2), (2, 2), None)
VEHICLE_COUNT = 20 # size constraint in place, may not always fit
AUTOFLOW_PERCENTAGE = 50
#=========================================


# Generate virtual landscape
landscape = Landscape(*LANDSCAPE_SIZE)
landscape.generate_new_landscape(desiredFeatures=LANDSCAPE_FEATURES, filler=LANDSCAPE_FILLER)

# There must be at least one road within the map area
assert len(landscape.intersections) > 4

# Check for overlapping roads
for roadA in landscape.roads:
    for roadB in landscape.roads:
        if roadA != roadB:
            if doIntersect(
                Point(*roadA.startPosReal),
                Point(*roadA.endPosReal),
                Point(*roadB.startPosReal),
                Point(*roadB.endPosReal)
            ):
                print(roadA.startPosReal, roadA.endPosReal)
                print(roadB.startPosReal, roadB.endPosReal)
                raise Exception("Roads overlap, this should not occur")

# Compute average road speed for all roads within map area
road_speeds = 0
road_count = 0
for road in landscape.roads:
    if (
        1 <= road.start[0] <= landscape.xSize and 1 <= road.start[1] <= landscape.ySize or 
        1 <= road.end[0] <= landscape.xSize and 1 <= road.end[1] <= landscape.ySize
    ):
        road_speeds += road.speedLimit
        road_count += 1
AVERAGE_ROAD_SPEED = road_speeds / road_count
AVERAGE_ROAD_SPEED_MPS = AVERAGE_ROAD_SPEED * 1000 / 3600

# Create two pools of available starting coordinates (as every road segment has a pair of opposite roads)
available_coordinates = [
    [
        (i, j) for i in range(1, landscape.xSize+1) for j in range(1, landscape.ySize+1) 
        if (i, j) in landscape.coordToRoad
    ],
    [
        (i, j) for i in range(1, landscape.xSize+1) for j in range(1, landscape.ySize+1) 
        if (i, j) in landscape.coordToRoad
    ]
]

# Uncomment the line below to always generate a valid vehicle count
VEHICLE_COUNT = randint(1, len(available_coordinates[0]) * 2)

# Check that the vehicle count does not exceed the maximum allowed vehicle count
assert VEHICLE_COUNT <= len(available_coordinates[0]) * 2

# Array storing all vehicle agents
vehicles: list[Vehicle] = []
selfish_vehicles: list[Vehicle] = []
autoflow_vehicles: list[Vehicle] = []

# Determine EV distribution
EV_percentage = randint(10, 20) # based on real world data
EV_count = EV_percentage * VEHICLE_COUNT // 100 # number of EVs to spawn

# Determine AutoFlow distribution
marked_indexes = set(sample([i for i in range(VEHICLE_COUNT)], VEHICLE_COUNT * AUTOFLOW_PERCENTAGE // 100))

current_index = 0

# Spawn EVs
while current_index < EV_count:
    if current_index in marked_indexes:
        vehicle = ElectricVehicle(useAutoFlow=True)
        autoflow_vehicles.append(vehicle)
    else:
        vehicle = ElectricVehicle(useAutoFlow=False)
        selfish_vehicles.append(vehicle)
    vehicles.append(vehicle)
    current_index += 1

# Spawn conventional vehicles
while current_index < VEHICLE_COUNT:
    if current_index in marked_indexes:
        vehicle = ConventionalVehicle(useAutoFlow=True)
        autoflow_vehicles.append(vehicle)
    else:
        vehicle = ConventionalVehicle(useAutoFlow=False)
        selfish_vehicles.append(vehicle)
    vehicles.append(vehicle)
    current_index += 1

# Assign random starting coordinates to all vehicles
for vehicle in vehicles:

    # Select random pool
    poolID = randint(0, 1) 
    if len(available_coordinates[poolID]) == 0:
        poolID = 1-poolID # if current pool is used up, use the other pool

    # Select random coordinate from pool, and determine which road it is on
    coordIndex = randint(0, len(available_coordinates[poolID]) - 1) 
    coord = available_coordinates[poolID][coordIndex]
    road = landscape.coordToRoad[coord][poolID]

    vehicle.setLocation(road, road.positionTable[coord]) # set vehicle's starting location

    available_coordinates[poolID].pop(coordIndex) # remove assigned coord from pool

for road in landscape.roads: # sort vehicle stacks, cars at the front are at the front/start of the deque
    road.vehicleStack = deque(sorted(road.vehicleStack, key = lambda vehicle: vehicle.position, reverse=True))

# Create two pools of available destination coordinates (as every road segment has a pair of opposite roads)
available_coordinates = [
    [
        (i, j) for i in range(1, landscape.xSize+1) for j in range(1, landscape.ySize+1) 
        if (i, j) in landscape.coordToRoad
    ],
    [
        (i, j) for i in range(1, landscape.xSize+1) for j in range(1, landscape.ySize+1) 
        if (i, j) in landscape.coordToRoad
    ]
]

# Assign random destination coordinates to all vehicles
for vehicle in vehicles:

    # Select random pool
    poolID = randint(0, 1) 
    if len(available_coordinates[poolID]) == 0:
        poolID = 1-poolID # if current pool is used up, use the other pool

    # Select random coordinate from pool, and determine which road it is on
    coordIndex = randint(0, len(available_coordinates[poolID]) - 1) 
    coord = available_coordinates[poolID][coordIndex]
    road = landscape.coordToRoad[coord][poolID]

    vehicle.setDestination(road, road.positionTable[coord]) # set vehicle's destination location

    available_coordinates[poolID].pop(coordIndex) # remove assigned coord from pool

# ===============================================================================================

# Helper functions

def getRealPositionOnRoad(road: Road, position: float) -> tuple[float, float]:
    """
    Calculates the real 2D position given road and a normalised position.
    """
    if road.direction == "N":
        return (road.startPosReal[0], road.startPosReal[1] + road.length * position)
    elif road.direction == "S":
        return (road.startPosReal[0], road.startPosReal[1] - road.length * position)
    elif road.direction == "E":
        return (road.startPosReal[0] + road.length * position, road.startPosReal[1])
    elif road.direction == "W":
        return (road.startPosReal[0] - road.length * position, road.startPosReal[1])
    
def euclideanDistance(pos1: tuple[float, float], pos2: tuple[float, float]) -> float:
    """
    Calculates the euclidean distance between two positions.
    The unit of measurement is metres.
    """
    return ((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)**0.5

# Main functions

def computeRoutes():
    """
    Compute the routes for selfish vehicles first, then AutoFlow vehicles.
    """
    #computeSelfishVehicleRoutes(selfish_vehicles)
    computeAutoflowVehicleRoutes(autoflow_vehicles)

def computeSelfishVehicleRoutes(selfish_vehicles: list[Vehicle]):
    """
    Selfish vehicles perform basic A* without awareness of other vehicles.
    Path allocation is computed in no particular order.

    Each node is a tuple that stores (fcost, hcost, gcost, tiebreaker, road, position).
    - fcost: sum of gcost and hcost, node with lowest fcost will be evaluated first
    - hcost: optimistic approximate time required to reach destination using AVERAGE_ROAD_SPEED
    - gcost: cost so far i.e. time taken so far, represents the ABSOLUTE time
    - tiebreaker: an unique integer used as a tiebreaker when all costs are equal

    Every node pushed into the Open list will be the start of a road (or the starting position of the vehicle).
    The Closed list contains all visited nodes (including end points of a road as well as the starting position).
    """

    routes: list[list[tuple[float, float]]] = []

    for vehicle in selfish_vehicles:

        tiebreaker = 0 # tiebreaker value for when all costs are equal

        # Hashmap that maps each node to their fcost
        node_fcost: dict[tuple[int, int], float] = defaultdict(lambda: float("inf"))

        # Hashmap that stores the previous node of each node
        previous_node: dict[tuple[tuple[float, float], float], tuple[tuple[float, float], float]] = {}        
        # previous_node[(real position, normalised position)] => (real position, normalised position)
        # NOTE: normalised position is used to handle roads where startPosReal and endPosReal are equal
        
        # Calculate real destination position
        destination_position = getRealPositionOnRoad(vehicle.destinationRoad, vehicle.destinationPosition)

        # Nodes are the starting points of each road, can also be the starting point of the vehicle
        open_nodes: list[float, float, float, Road, float] = [] # Open is a priority queue
        closed_nodes: set[tuple(Road, float)] = set() # Closed can just be a set

        # Calculate the cost variables of the starting position
        gcost = 0
        hcost = euclideanDistance(
            getRealPositionOnRoad(vehicle.road, vehicle.position), 
            destination_position
        ) / AVERAGE_ROAD_SPEED_MPS
        fcost = gcost + hcost

        # Add starting position of the vehicle to open_nodes
        start_node = (fcost, hcost, gcost, tiebreaker, vehicle.road, vehicle.position)
        tiebreaker += 1
        heappush(open_nodes, start_node) 

        while True: # loop until target point has been reached

            if len(open_nodes) == 0:
                raise Exception("Path does not exist")

            # Explore the node with the lowest fcost (hcost is tiebreaker)
            fcost, hcost, gcost, tiebreaker, road, position = heappop(open_nodes)
            real_position = getRealPositionOnRoad(road, position)

            # Add current to closed_nodes
            closed_nodes.add((road, position))

            # If destination is same as current position (by chance) then skip this vehicle
            if road == vehicle.destinationRoad and position == vehicle.destinationPosition:
                break

            # If destination is on the same road in front of the current position then calculate single instruction
            if road == vehicle.destinationRoad and position < vehicle.destinationPosition:
                previous_node[(destination_position, vehicle.destinationPosition)] = (real_position, position)
                break

            if (road, 1) in closed_nodes: # if current road is the starting road, skip
                continue

            # Otherwise, create instruction to move to the end of the road as there is no other choice
            roadEndPosition: tuple[float, float] = road.endPosReal

            # Store references to road intersection for easy reference
            road_start_intersection: Intersection = landscape.intersections[road.start]
            road_end_intersection: Intersection = landscape.intersections[road.end]

            # Initiate time cost of reaching road end node (ignoring traffic lights)
            time_taken = euclideanDistance(
                real_position,
                roadEndPosition
            ) / road.speedLimit_MPS

            # Compute waiting time until the next green light
            if len(road_end_intersection.neighbours) >= 3:
                current_modulus_time = gcost % (len(road_end_intersection.neighbours) * road_end_intersection.trafficLightDuration)
                if (
                    (road_end_intersection.trafficLightLookup[road_start_intersection] + 1) * road_end_intersection.trafficLightDuration 
                    > current_modulus_time
                ):
                    waiting_time = (
                        road_end_intersection.trafficLightLookup[road_start_intersection] * road_end_intersection.trafficLightDuration 
                        - current_modulus_time
                    )
                    if waiting_time > 0: # Case 1: current time is earlier in the cycle
                        pass
                    else: # Case 2: current time is within the green light duration, allow vehicle through
                        waiting_time = 0
                else: # Case 3: current time is later in the cycle
                    waiting_time = (
                        len(road_end_intersection.neighbours) * road_end_intersection.trafficLightDuration
                        - current_modulus_time 
                        + road_end_intersection.trafficLightLookup[road_start_intersection] * road_end_intersection.trafficLightDuration
                    )
                time_taken += waiting_time # update time taken to reflect traffic light waiting time

            # Set previous node of road end node to road start node
            previous_node[(roadEndPosition, 1)] = (real_position, position)

            # Add road end to closed nodes
            closed_nodes.add((road, 1))

            # Update variables
            position = 1
            real_position = roadEndPosition
            gcost += time_taken
            hcost = euclideanDistance(
                real_position, 
                destination_position
            ) / AVERAGE_ROAD_SPEED_MPS
            fcost = gcost + hcost

            # Examine neighbours
            for neighbour_intersection in road_end_intersection.neighbours:

                # No U turns allowed
                if neighbour_intersection == road_start_intersection:
                    continue

                # Store reference to neighbour road for easy reference
                neighbour_road = landscape.roadmap[road_end_intersection.coordinates()][neighbour_intersection.coordinates()]
                
                # If neighbour is in closed, skip
                if (neighbour_road, 0) in closed_nodes:
                    continue
                
                # Time cost of reaching neighbour node is the traversal time of virtual pathway
                time_taken = road_end_intersection.intersectionPathways[road_start_intersection][neighbour_intersection].traversalTime     
                # NOTE: traffic light waiting time is already accounted for by the gcost of reaching road end node

                # Compute all cost values
                neighbour_gcost = gcost + time_taken
                neighbour_hcost = euclideanDistance(
                    neighbour_road.startPosReal, 
                    destination_position
                ) / AVERAGE_ROAD_SPEED_MPS
                neighbour_fcost = neighbour_gcost + neighbour_hcost

                neighbour_node = (neighbour_fcost, neighbour_hcost, neighbour_gcost, tiebreaker, neighbour_road, 0)
                tiebreaker += 1

                # Push neighbour node into open list if fcost is smaller than the existing cost
                if neighbour_fcost < node_fcost[(neighbour_road, 0)]:
                    node_fcost[(neighbour_road, 0)] = neighbour_fcost
                    previous_node[(neighbour_road.startPosReal, 0)] = (real_position, position)
                    heappush(open_nodes, neighbour_node) # it does not matter whether neighbour is already in open list

        # Initiate a list that stores the sequence of (next position, relative time taken) for the vehicle
        route = [] 

        # Initiate traceback variables
        current_real_position, current_position = destination_position, vehicle.destinationPosition

        # Create route using previous_node hashmap
        while (current_real_position, current_position) in previous_node:

            # Unpack previous node information
            previous_real_position, previous_position = previous_node[(current_real_position, current_position)]
            
            # Append new instruction
            if previous_real_position != current_real_position: # skip redundant instructions on roads with 0 length
                route.append(current_real_position)

            # Update traceback variables
            current_real_position, current_position = previous_real_position, previous_position

        # Reverse instructions to obtain chronological order
        route.reverse()
        print()
        print(route)

        # Store computed route in routes list            
        routes.append(route)

    # for route in routes:
    #     print(routes)

def computeAutoflowVehicleRoutes(autoflow_vehicles: list[Vehicle]):
    """
    AutoFlow vehicles perform cooperative A* with awareness of other AutoFlow vehicles.
    Path allocation is computed in ascending order of emission rate.

    A space-time reservation table is used to keeps track of the number of vehicles on each road
    at any timestamp (in seconds). This greatly enhances the accuracy of cost functions when
    evaluating which path to take, as more congested roads would take longer to traverse.    

    Each node is a tuple that stores (fcost, hcost, gcost, tiebreaker, road, position).
    - fcost: sum of gcost and hcost, node with lowest fcost will be evaluated first
    - hcost: optimistic approximate time required to reach destination using AVERAGE_ROAD_SPEED
    - gcost: cost so far i.e. time taken so far, represents the ABSOLUTE time
    - tiebreaker: an unique integer used as a tiebreaker when all costs are equal

    Every node pushed into the Open list will be the start of a road (or the starting position of the vehicle).
    The Closed list contains all visited nodes (including end points of a road as well as the starting position).
    """

    routes: list[list[tuple[float, float]]] = []

    # Get a sorted list of vehicles
    sorted_vehicles = sorted(autoflow_vehicles, key = lambda vehicle: vehicle.emissionRate)

    # Set up space-time reservation table 
    reservation_table: dict[int, dict[int, int]] = defaultdict(lambda: defaultdict(int))
    # reservation_table[roadID][timestamp in seconds] => number of vehicles on road at timestamp

    for vehicle in sorted_vehicles:

        tiebreaker = 0 # tiebreaker value for when all costs are equal

        # Hashmap that maps each node to their fcost
        node_fcost: dict[tuple[int, int], float] = defaultdict(lambda: float("inf"))

        # Hashmap that stores the previous node, road index in landscape.roads and ABSOLUTE time cost of each node
        previous_node: dict[
            tuple[tuple[float, float], float], tuple[tuple[tuple[float, float], float], int, float]
        ] = {}
        # previous_node[(real position, normalised position)] => ((real position, normalised position), roadID, absolute time)
        # NOTE: normalised position is used to handle roads where startPosReal and endPosReal are equal
        # NOTE: ABSOLUTE time is needed to prevent time desync within reservation table
        
        # Calculate real destination position
        destination_position = getRealPositionOnRoad(vehicle.destinationRoad, vehicle.destinationPosition)

        # Nodes are the starting points of each road, can also be the starting point of the vehicle
        open_nodes: list[float, float, float, Road, float] = [] # Open is a priority queue
        closed_nodes: set[tuple(Road, float)] = set() # Closed can just be a set

        # Calculate the cost variables of the starting position
        gcost = 0
        hcost = euclideanDistance(
            getRealPositionOnRoad(vehicle.road, vehicle.position), 
            destination_position
        ) / AVERAGE_ROAD_SPEED_MPS
        fcost = gcost + hcost

        # Add starting position of the vehicle to open_nodes
        start_node = (fcost, hcost, gcost, tiebreaker, vehicle.road, vehicle.position)
        tiebreaker += 1
        heappush(open_nodes, start_node) 

        while True: # loop until target point has been reached

            if len(open_nodes) == 0:
                raise Exception("Path does not exist")

            # Explore the node with the lowest fcost (hcost is tiebreaker)
            fcost, hcost, gcost, tiebreaker, road, position = heappop(open_nodes)
            real_position = getRealPositionOnRoad(road, position)

            # Add current to closed_nodes
            closed_nodes.add((road, position))

            # If destination is same as current position (by chance) then skip this vehicle
            if road == vehicle.destinationRoad and position == vehicle.destinationPosition:
                break

            # If destination is on the same road in front of the current position then calculate single instruction
            if road == vehicle.destinationRoad and position < vehicle.destinationPosition:
                time_taken = euclideanDistance(
                    real_position,
                    destination_position
                ) / road.speedLimit_MPS # fastest time estimation from start of the road to the destination
                previous_node[(destination_position, vehicle.destinationPosition)] = (
                    (real_position, position),
                    road.roadID,
                    gcost + time_taken 
                )
                break

            if (road, 1) in closed_nodes: # if current road is the starting road, skip
                continue

            # Otherwise, create instruction to move to the end of the road as there is no other choice
            roadEndPosition: tuple[float, float] = road.endPosReal

            # Store references to road intersection for easy reference
            road_start_intersection: Intersection = landscape.intersections[road.start]
            road_end_intersection: Intersection = landscape.intersections[road.end]

            # Initiate time cost of reaching road end node (ignoring traffic lights & any congestion)
            time_taken = euclideanDistance(
                real_position,
                roadEndPosition
            ) / road.speedLimit_MPS

            # Compute waiting time until the next green light
            if len(road_end_intersection.neighbours) >= 3:
                current_modulus_time = gcost % (len(road_end_intersection.neighbours) * road_end_intersection.trafficLightDuration)
                if (
                    (road_end_intersection.trafficLightLookup[road_start_intersection] + 1) * road_end_intersection.trafficLightDuration 
                    > current_modulus_time
                ):
                    waiting_time = (
                        road_end_intersection.trafficLightLookup[road_start_intersection] * road_end_intersection.trafficLightDuration 
                        - current_modulus_time
                    )
                    if waiting_time > 0: # Case 1: current time is earlier in the cycle
                        pass
                    else: # Case 2: current time is within the green light duration, allow vehicle through
                        waiting_time = 0
                else: # Case 3: current time is later in the cycle
                    waiting_time = (
                        len(road_end_intersection.neighbours) * road_end_intersection.trafficLightDuration
                        - current_modulus_time 
                        + road_end_intersection.trafficLightLookup[road_start_intersection] * road_end_intersection.trafficLightDuration
                    )
                time_taken += waiting_time # update time taken to reflect traffic light waiting time

                # Compute cost of reaching road end node (taking congestion into account)
                time_taken += (
                    reservation_table[road.roadID][int(gcost)]
                    // road_end_intersection.trafficPassthroughRate[road_start_intersection]
                    * road_end_intersection.trafficLightDuration
                ) # update time taken to reflect the number of traffic light cycles waited

            # Set previous node of road end node to road start node
            previous_node[(roadEndPosition, 1)] = (
                (real_position, position),
                road.roadID,
                gcost + time_taken
            )

            # Add road end to closed nodes
            closed_nodes.add((road, 1))

            # Update variables
            position = 1
            real_position = roadEndPosition
            gcost += time_taken
            hcost = euclideanDistance(
                real_position, 
                destination_position
            ) / AVERAGE_ROAD_SPEED_MPS
            fcost = gcost + hcost

            # Examine neighbours
            for neighbour_intersection in road_end_intersection.neighbours:

                # No U turns allowed
                if neighbour_intersection == road_start_intersection:
                    continue

                # Store reference to neighbour road for easy reference
                neighbour_road = landscape.roadmap[road_end_intersection.coordinates()][neighbour_intersection.coordinates()]
                
                # If neighbour is in closed, skip
                if (neighbour_road, 0) in closed_nodes:
                    continue
                
                # Time cost of reaching neighbour node is the traversal time of virtual pathway
                time_taken = road_end_intersection.intersectionPathways[road_start_intersection][neighbour_intersection].traversalTime     
                # NOTE: traffic light waiting time is already accounted for by the gcost of reaching road end node

                # Compute all cost values
                neighbour_gcost = gcost + time_taken
                neighbour_hcost = euclideanDistance(
                    neighbour_road.startPosReal, 
                    destination_position
                ) / AVERAGE_ROAD_SPEED_MPS
                neighbour_fcost = neighbour_gcost + neighbour_hcost

                neighbour_node = (neighbour_fcost, neighbour_hcost, neighbour_gcost, tiebreaker, neighbour_road, 0)
                tiebreaker += 1

                # Push neighbour node into open list if fcost is smaller than the existing cost
                if neighbour_fcost < node_fcost[(neighbour_road, 0)]:
                    node_fcost[(neighbour_road, 0)] = neighbour_fcost
                    previous_node[(neighbour_road.startPosReal, 0)] = (
                        (real_position, position),
                        neighbour_road.roadID,
                        -1 # skipped to avoid double marking and time desync in reservation table
                    )
                    heappush(open_nodes, neighbour_node) # it does not matter whether neighbour is already in open list

        # Initiate a list that stores the sequence of (next position, relative time taken) for the vehicle
        route = [] 

        # Initiate traceback variables
        current_real_position, current_position = destination_position, vehicle.destinationPosition
        previousTimestamp = 0

        # Create route using previous_node hashmap
        while (current_real_position, current_position) in previous_node:

            # Unpack previous node information
            node, roadID, timestamp = previous_node[(current_real_position, current_position)]
            previous_real_position, previous_position = node

            # Append new instruction
            if previous_real_position != current_real_position: # skip redundant instructions on roads with 0 length
                route.append(current_real_position)

            # Update congestion status of used road during the usage time period
            if timestamp != -1: # skip virtual pathways for reservation table marking
                for i in range(int(previousTimestamp), ceil(timestamp)):
                    reservation_table[roadID][i] += 1

            # Update traceback variables
            previousTimestamp = timestamp
            current_real_position, current_position = previous_real_position, previous_position

        # Reverse instructions to obtain chronological order
        route.reverse()
        print()
        print(route)

        # Store computed route in routes list                
        routes.append(route)

    # for route in routes:
    #     print(routes)


# for vehicle in selfish_vehicles:
#     #print(vehicle.road, vehicle.road.positionTable, vehicle.position)
#     #print(vehicle.destinationPosition, vehicle.destinationRoad)
#     print(
#         getRealPositionOnRoad(vehicle.road, vehicle.position),
#         getRealPositionOnRoad(vehicle.destinationRoad, vehicle.destinationPosition)
#     )
for vehicle in autoflow_vehicles:
    #print(vehicle.road, vehicle.road.positionTable, vehicle.position)
    #print(vehicle.destinationPosition, vehicle.destinationRoad)
    print(
        getRealPositionOnRoad(vehicle.road, vehicle.position),
        getRealPositionOnRoad(vehicle.destinationRoad, vehicle.destinationPosition)
    )
# for road in landscape.roads:
#     if len(road.vehicleStack) != 0:
#         print([vehicle.position for vehicle in road.vehicleStack])
print(VEHICLE_COUNT)
computeRoutes()