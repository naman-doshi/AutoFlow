"""
This script contains the AutoFlow system, which consists of the following parts:
- Virtual landscape (defined & generated by Components.py)
- Vehicle agent object definitions
- Multi-agent pathfinding algorithm

The distribution of EVs is based on https://www.iea.org/reports/global-ev-outlook-2023/executive-summary.
The number of vehicle agents to spawn in must be smaller than the (number of available coordinates * 2),
this is because currently vehicles are placed into random cell coordinates (which must be unique).

The following input variables are used to describe the virtual simualtion:
- LANDSCAPE_SIZE: a tuple describing the approximate dimensions of the landscape, see LandscapeComponents.py
- VEHICLE_COUNT: the exact number of vehicle agents to be spawned into the simulation
- AUTOFLOW_PERCENTAGE: the percentage of vehicle agents using AutoFlow
"""


#================ IMPORTS ================
from LandscapeComponents import *
from VehicleAgents import *

from random import sample
from heapq import *
#=========================================


#================ INPUTS =================
LANDSCAPE_SIZE = (5, 5)
LANDSCAPE_FEATURES = [
    (LandPlotDescriptor((2, 2), (1, 1)), 5)
]
LANDSCAPE_FILLER = LandPlotDescriptor((2, 2), (2, 2), None)
VEHICLE_COUNT = 20
AUTOFLOW_PERCENTAGE = 50
#=========================================


# Generate virtual landscape
landscape = Landscape(*LANDSCAPE_SIZE)
landscape.generate_new_landscape(desiredFeatures=LANDSCAPE_FEATURES, filler=LANDSCAPE_FILLER)

# There must be at least one road within the map area
assert len(landscape.intersections) > 4

# Create two pools of available starting coordinates (as every road segment has a pair of opposite roads)
available_coordinates = [
    [
        (i, j) for i in range(1, landscape.xSize+1) for j in range(1, landscape.ySize+1) 
        if (i, j) in landscape.coordToRoad
    ],
    [
        (i, j) for i in range(1, landscape.xSize+1) for j in range(1, landscape.ySize+1) 
        if (i, j) in landscape.coordToRoad
    ]
]

# Uncomment the line below to always generate a valid vehicle count
VEHICLE_COUNT = randint(1, len(available_coordinates[0]) * 2)

# Check that the vehicle count does not exceed the maximum allowed vehicle count
assert VEHICLE_COUNT <= len(available_coordinates[0]) * 2

# Array storing all vehicle agents
vehicles: list[Vehicle] = []

# Determine EV distribution
EV_percentage = randint(10, 20) # based on real world data
EV_count = EV_percentage * VEHICLE_COUNT // 100 # number of EVs to spawn

# Determine AutoFlow distribution
marked_indexes = set(sample([i for i in range(VEHICLE_COUNT)], VEHICLE_COUNT * AUTOFLOW_PERCENTAGE // 100))

current_index = 0

# Spawn EVs
while current_index < EV_count:
    if current_index in marked_indexes:
        vehicles.append(ElectricVehicle(useAutoFlow=True))
    else:
        vehicles.append(ElectricVehicle(useAutoFlow=False))
    current_index += 1

# Spawn conventional vehicles
while current_index < VEHICLE_COUNT:
    if current_index in marked_indexes:
        vehicles.append(ConventionalVehicle(useAutoFlow=True))
    else:
        vehicles.append(ConventionalVehicle(useAutoFlow=False))
    current_index += 1

# Assign random starting coordinates to all vehicles
for vehicle in vehicles:

    # Select random pool
    poolID = randint(0, 1) 
    if len(available_coordinates[poolID]) == 0:
        poolID = 1-poolID # if current pool is used up, use the other pool

    # Select random coordinate from pool, and determine which road it is on
    coordIndex = randint(0, len(available_coordinates[poolID]) - 1) 
    coord = available_coordinates[poolID][coordIndex]
    road = landscape.coordToRoad[coord][poolID]

    vehicle.setLocation(road, road.positionTable[coord]) # set vehicle's starting location

    available_coordinates[poolID].pop(coordIndex) # remove assigned coord from pool

for road in landscape.roads: # sort vehicle stacks, cars at the front are at the front/start of the deque
    road.vehicleStack = deque(sorted(road.vehicleStack, key = lambda vehicle: vehicle.position, reverse=True))

# Create two pools of available destination coordinates (as every road segment has a pair of opposite roads)
available_coordinates = [
    [
        (i, j) for i in range(1, landscape.xSize+1) for j in range(1, landscape.ySize+1) 
        if (i, j) in landscape.coordToRoad
    ],
    [
        (i, j) for i in range(1, landscape.xSize+1) for j in range(1, landscape.ySize+1) 
        if (i, j) in landscape.coordToRoad
    ]
]

# Assign random destination coordinates to all vehicles
for vehicle in vehicles:

    # Select random pool
    poolID = randint(0, 1) 
    if len(available_coordinates[poolID]) == 0:
        poolID = 1-poolID # if current pool is used up, use the other pool

    # Select random coordinate from pool, and determine which road it is on
    coordIndex = randint(0, len(available_coordinates[poolID]) - 1) 
    coord = available_coordinates[poolID][coordIndex]
    road = landscape.coordToRoad[coord][poolID]

    vehicle.setDestination(road, coord) # set vehicle's destination location

    available_coordinates[poolID].pop(coordIndex) # remove assigned coord from pool
    

for vehicle in vehicles:
    #print(vehicle.road, vehicle.road.positionTable, vehicle.position)
    print(vehicle.destinationCoord, vehicle.destinationRoad)
# for road in landscape.roads:
#     if len(road.vehicleStack) != 0:
#         print([vehicle.position for vehicle in road.vehicleStack])
print(VEHICLE_COUNT)