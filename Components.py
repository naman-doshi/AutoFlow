"""
This script contains all of the object definitions required for the simulation.

Environmental component hierarchy:
- Landscape
    - Landplots
    - Intersections (including traffic lights)
    - Roads

An algorithm for generating random landscapes is included.
"""


#================ IMPORTS ================
from collections import defaultdict
from random import randint
from copy import deepcopy
#=========================================


class LandPlot:

    """
    A land plot is a rectangular area where no roads can spawn.
    The size of a land plot is (number of cells taken in x axis) * (number of cells taken in y axis).
    The coordinates of each land plot must be unique.

    NOTE: The properties may become invalid after a new landscape is generated via generate_new_landscape,
    due to the road fitting algorithm giving the roads extra cells (as they have a physical width and height).
    However, this has no implications on the simulation as buildings are static environment components.
    """

    def __init__(self, xSize: int, ySize: int) -> None:

        # Set size of the land plot in number of cells
        self.xSize = xSize
        self.ySize = ySize

    def set_coordinate(self, xPos: int, yPos: int) -> None:

        # Set lower left coordinates of the land plot
        self.xPos = xPos
        self.yPos = yPos

    def area(self) -> int:
        return self.xSize * self.ySize

    def __hash__(self) -> int:
        return hash((self.xPos, self.yPos))


class Intersection:

    """
    A intersection is a point where two or more roads cross.
    An intersection is spawned at all four corners of a land plot.
    The coordinate (xPos, yPos) must be unique for each intersection.

    Each intersection also contains a neighbours list that points to all its adjacent neighbours (up to four)
    """

    def __init__(self, xPos: float, yPos: float) -> None:

        # Set coordinates of the intersection
        self.xPos = xPos
        self.yPos = yPos

        # Initiate neighbour references
        self.neighbours: list[Intersection] = []

    def coordinates(self) -> tuple[int, int]:
        return (self.xPos, self.yPos)

    def __hash__(self) -> int:
        return hash((self.xPos, self.yPos))


class Road:

    """
    A road is one way lane between two intersections, or an intersection and one side of the map border.
    By default, two roads going opposite directions are constructed for every group of road tiles. 

    Each road has the following properties:
    - Starting coordinate and ending coordinate
    - Speed limit in km/h

    Length is simply the number of tiles the road spans over plus one.
    The plus one comes from the fact that the road starts and ends at the centre of two coordinates.
    """

    def __init__(self, start: tuple[int, int], end: tuple[int, int]) -> None:

        # Set starting intersection and ending intersection of the road
        self.start = start
        self.end = end

        # Set length and speed limit
        self.length = abs(end[0] - start[0]) + abs(end[1] - start[1])
        self.set_speed_limit()

    # this method should be overwritten by subclasses of road, e.g. highway => 120km/h
    def set_speed_limit(self, speedlimit: float = 60) -> None: 
        self.speedLimit = speedlimit


class LandPlotDescriptor:

    """
    Used to describe desirable "features" of a virtual landscape.
    Features e.g. residental rows are described through their corresponding land plot sizes.
    A list of LandPlotDescriptor will be passed to the landscape generator algorithm for virtual landscape generation.

    Assuming that the generated landscape faces North:
    - xRange is the horizontal width (west to east) of the land plot
    - yRange is the vertical length (south to north) of the land plot
    - randomOrientation indicates whether x and y can be swapped when generating the specified landplot
    """

    def __init__(self, xRange: tuple[int, int], yRange: tuple[int, int], randomOrientation: bool = True) -> None:

        # Set size range of x and size range of y in number of cells
        self.xRange = xRange
        self.yRange = yRange

        # Whether x and y can be swapped (randomly) when generating landscape
        self.randomOrientation = randomOrientation


class Landscape:

    """
    A landscape is a grid structure that contains straight roads and rectangular land plots.
    The size of the landscape is (number of cells fittable in x axis) * (number of cells fittable in y axis).
    The real distance covered by each (square) cell on either axes is defined by cellSize in metres.
    This object represents an entire virtual landscape, storing references to all components.

    NOTE: x is the horizontal (west to east) coordinate, y is the vertical (south to north) coordinate,
    therefore y is indexed first (row in matrix), then x (column in matrix).

    NOTE: Landscapes generated by the generate_new_landscape method may have up to double the xSize and ySize,
    due to the road fitting algorithm giving the roads extra cells (as they have a physical width and height).
    """

    def __init__(self, xSize: int, ySize: int, cellSize: int = 100) -> None:

        # Set size of the generated landscape in cell count, e.g. 10 x 10 cells with a cellSize of 100 => 1km^2 area
        self.xSize = xSize
        self.ySize = ySize
        cellSize = cellSize

        # Initiate component references
        self.reset_landscape()

    def reset_landscape(self) -> None:

        # 2D matrix representing the COMPACT land plot allocations i.e. no roads, x and y are cell coordinates
        self.gridMatrix: list[list[tuple[int, int]]] = [[None for i in range(self.xSize)] for j in range(self.ySize)]

        # Counter for the amount of available area remaing in gridMatrix
        self.availableArea = self.xSize * self.ySize

        # 2D matrix representing the generated landscape, x and y are cell coordinates
        self.landscapeMatrix: list[list[str]] = [[None for i in range(self.xSize)] for j in range(self.ySize)]

        # Component references
        self.landPlots: list[LandPlot] = []
        self.landMap: dict[tuple[int, int]: LandPlot] = defaultdict(lambda: None) # coord: land plot
        self.roads: list[Road] = []
        self.intersections: dict[tuple[int, int]] = defaultdict(lambda: None) # coord: intersection

        # Hashmap for accessing roads via intersection coordinates, e.g. self.roadmap[intersection1][intersection2]
        self.roadmap: dict[tuple[int, int]: dict[tuple[int, int]: Road]] = defaultdict(dict)

        # Hashmap for accessing the road of a particular coordinate, first Road has smaller coords than second Road
        self.coordToRoad: dict[tuple[int, int]: tuple[Road, Road]] = {} 
        # i.e. first Road goes west or south, second Road goes east or north

    @staticmethod
    def generate_features(desiredFeatures: list[tuple[LandPlotDescriptor, int]]) -> list[LandPlot]:
        """
        Generates and returns a list of feature groups from a list of LandPlotDescriptor and max occurrence counts.
        Each feature group represents a desired feature.
        """

        generatedFeatures: list[LandPlot] = []

        for desiredFeature, maxOccurrenceCount in desiredFeatures:

            if maxOccurrenceCount <= 0: # must be positive
                continue

            for i in range(maxOccurrenceCount):

                # Generate land plot feature
                if desiredFeature.randomOrientation == True:
                    # Randomly swap the x and y sizes
                    if randint(0, 1):
                        feature = LandPlot(
                            randint(*desiredFeature.xRange), 
                            randint(*desiredFeature.yRange)
                        )
                    else:
                        feature = LandPlot(
                            randint(*desiredFeature.yRange), 
                            randint(*desiredFeature.xRange)
                        )
                else:
                    feature = LandPlot(
                        randint(*desiredFeature.xRange), 
                        randint(*desiredFeature.yRange)
                    )

                # Add feature to generatedFeatures list
                generatedFeatures.append(feature)

        return generatedFeatures
    
    def get_valid_placements(self, feature: LandPlot) -> list[tuple[int, int]]:
        """
        Returns a list of all possible bottom left coordinates where the feature land plot can fit within self.gridMatrix.
        """

        valid_coordinates: list[tuple[int, int]] = []

        # Check every possibly valid placement coordinate
        for ycoord in range(self.ySize - feature.ySize + 1):
            for xcoord in range(self.xSize - feature.xSize + 1):

                # Assume current placement coordinate is valid
                valid = True

                # Check every cell covered by the feature land plot                
                for y in range(ycoord, ycoord + feature.ySize):
                    for x in range(xcoord, xcoord + feature.xSize):

                        # cell has already been taken by another land plot
                        if self.gridMatrix[y][x] != None: 
                            valid = False
                            break

                    if not valid:
                        break
                
                # Append valid coordinates to list
                if valid:
                    valid_coordinates.append((xcoord, ycoord))

        return valid_coordinates
    
    def place_feature(self, feature: LandPlot, xPos: int, yPos: int) -> None:
        """
        Places a feature land plot within self.gridMatrix.
        """

        feature.set_coordinate(xPos, yPos)

        # Mark every cell covered by the feature land plot as taken
        for y in range(yPos, yPos + feature.ySize):
            for x in range(xPos, xPos + feature.xSize):
                self.gridMatrix[y][x] = (xPos, yPos)
                self.availableArea -= 1

    def connect_intersections(self, intersection1: Intersection, intersection2: Intersection) -> None:
        """
        Connects two intersections by creating two roads that go in opposite directions.
        Then updates self.coordToRoad for vehicle agents to easily locate the road they're on.
        """

        # Generate random speed limit for both roads
        random_speed_limit = randint(40, 80)

        # Add intersection to component references
        self.intersections[intersection1.coordinates()] = intersection1
        self.intersections[intersection2.coordinates()] = intersection2

        # Create road from intersection 1 to intersection 2
        intersection1.neighbours.append(intersection2)
        road1 = Road(intersection1.coordinates(), intersection2.coordinates())
        road1.set_speed_limit(random_speed_limit)
        self.roadmap[intersection1.coordinates()][intersection2.coordinates()] = road1
        self.roads.append(road1)

        # Create road from intersection 2 to intersection 1
        intersection2.neighbours.append(intersection1)
        road2 = Road(intersection2.coordinates(), intersection1.coordinates())
        road2.set_speed_limit(random_speed_limit)
        self.roadmap[intersection2.coordinates()][intersection1.coordinates()] = road2
        self.roads.append(road2)

        # Update self.coordToRoad to map every cell covered by road to road
        if intersection1.yPos == intersection2.yPos: # horizontally alligned

            if intersection1.xPos < intersection2.xPos: # intersection 1 is to the left of intersection 2
                roadWest, roadEast = road2, road1
            else: # intersection 2 is to the left of intersection 1
                roadWest, roadEast = road1, road2

            for xCoord in range(intersection1.xPos+1, intersection2.xPos):
                self.coordToRoad[(intersection1.yPos, xCoord)] = (roadWest, roadEast)

        else: # vertically alligned

            if intersection1.yPos < intersection2.yPos: # intersection 1 is to the south of intersection 2
                roadSouth, roadNorth = road2, road1
            else: # intersection 2 is to the south of intersection 1
                roadSouth, roadNorth = road1, road2

            for yCoord in range(intersection1.yPos+1, intersection2.yPos):
                self.coordToRoad[(yCoord, intersection1.xPos)] = (roadSouth, roadNorth)

    def label_intersections(self, pos1: tuple[int, int], pos2: tuple[int, int]):
        """
        Labels intersections on self.landscapeMatrix, as well as the roads in between.
        Does NOT create any intersection or road objects.
        """

        # Add intersection labels to self.landscapeMatrix
        self.landscapeMatrix[pos1[1]][pos1[0]] = "IS"
        self.landscapeMatrix[pos2[1]][pos2[0]] = "IS"

        # Add road labels between the two intersections to self.landscapeMatrix
        if pos1[1] == pos2[1]: # horizontal roads
            for xCoord in range(min(pos1[0], pos2[0])+1, max(pos1[0], pos2[0])):
                if self.landscapeMatrix[pos1[1]][xCoord] == None:
                    self.landscapeMatrix[pos1[1]][xCoord] = "HR"
        else: # vertical roads
            for yCoord in range(min(pos1[1], pos2[1])+1, max(pos1[1], pos2[1])):
                if self.landscapeMatrix[yCoord][pos1[0]] == None:
                    self.landscapeMatrix[yCoord][pos1[0]] = "VR"

    def generate_new_landscape(
            self, 
            desiredFeatures: list[tuple[LandPlotDescriptor, int]] = [], 
            filler: LandPlotDescriptor = LandPlotDescriptor((1, 1), (1, 1), False)
        ) -> None:
        """
        Algorithm for generating a random new landscape based on a list of desired features.

        The following optional parameters may be passed:
        - desiredFeatures: a list of (LandPlotDescriptor, maxCount) describing desired features and maximum occurrence
        - filler: a land plot used to populate the landscape, may occur indefinitely

        If the list of desired features is empty, or when no more desired features can fit, 
        filler land plot will be used to populate the landscape.

        The actual map area is (1, 1) to (xSize, ySize) inclusive, i.e. 1-indexed.
        This is because the perimeter of the landscape is generated artificially for the ease of road placements.
        
        The road filling algorithm may double the xSize and ySize of the generated landscape.
        Therefore, the generated map size will most likely NOT be the same as the initially defined map size.
        
        More speficially:
        - the final xSize ranges from xSize to xSize*2-1 inclusive
        - the final ySize ranges from ySize to ySize*2-1 inclusive

        NOTE: If filler isn't 1 by 1, the generated landscape may not be connected.
        """

        # Reset component references
        self.reset_landscape()

        # Generate feature land plots from desired features, then sort by decreasing area (place larger features first)
        featuresToAdd = Landscape.generate_features(desiredFeatures=desiredFeatures)
        featuresToAdd.sort(key = lambda feature: feature.area(), reverse = True)

        # Skip impossible placements quickly via temporary optimisation hashmap
        isUnplaceable: dict[tuple[int, int]: bool] = defaultdict(lambda: False)

        # Fit feature land plots into the landscape
        for feature in featuresToAdd:
            if isUnplaceable[(feature.xSize, feature.ySize)]:
                continue
            if feature.area() > self.availableArea:
                isUnplaceable[(feature.xSize, feature.ySize)] = True
                continue
            valid_coordinates = self.get_valid_placements(feature)
            if not valid_coordinates:
                isUnplaceable[(feature.xSize, feature.ySize)] = True
                continue
            self.place_feature(feature, *valid_coordinates[randint(0, len(valid_coordinates)-1)])

        # Generate filler land plots, then sort by decreasing area (place larger features first)
        fillerFeatures = Landscape.generate_features(desiredFeatures=[(filler, self.availableArea)])
        fillerFeatures.sort(key = lambda feature: feature.area(), reverse = True)

        # Fill in remaining area with filler, remaining area may not be completely filled if filler isn't 1 by 1
        for feature in fillerFeatures:
            if isUnplaceable[(feature.xSize, feature.ySize)]:
                continue
            valid_coordinates = self.get_valid_placements(feature)
            if not valid_coordinates:
                isUnplaceable[(feature.xSize, feature.ySize)] = True
                continue
            self.place_feature(feature, *valid_coordinates[randint(0, len(valid_coordinates)-1)])

        self.generate_landscape_matrix()


    def generate_landscape_matrix(self) -> None:
        """
        Generates and updates self.landscapeMatrix from self.gridMatrix.
        Landscape matrix is an unpacked version of grid matrix with road cells.
        """

        # Buffer arrays for road expansions
        xBuffer = [False for i in range(self.xSize)]
        yBuffer = [False for i in range(self.ySize)]

        # Counters for getting the new X and Y coordinates after road insertions
        xExtend = 0
        yExtend = 0

        self.landscapeMatrix = deepcopy(self.gridMatrix)

        # Extend width of landscape for new roads
        for prevX in range(self.xSize):
            for prevY in range(self.ySize):

                # Skip unassigned area
                if self.gridMatrix[prevY][prevX] == None:
                    continue
                
                # Calculate corresponding coordiantes in landscapeMatrix
                newX, newY = prevX + xExtend, prevY + yExtend

                # Check neighbour cell to the right, if it belongs to a different plot of land then add road
                if prevX < self.xSize-1 and self.gridMatrix[prevY][prevX] != self.gridMatrix[prevY][prevX+1]:

                    # Extend width of landscape matrix if not already extended
                    if not xBuffer[prevX]:
                        for y in range(self.ySize + yExtend):
                            self.landscapeMatrix[y].insert(
                                newX+1, 
                                self.landscapeMatrix[y][newX] if self.landscapeMatrix[y][newX] == self.landscapeMatrix[y][newX+1] 
                                else None
                            )      
                        xBuffer[prevX] = True
                        xExtend += 1

        # # Uncomment to see the results of horizontal extension
        # for i in range(len(self.landscapeMatrix)):
        #     print(self.landscapeMatrix[i])
        # print()

        # Extend length of landscape for new roads
        for prevY in range(self.ySize):
            for prevX in range(self.xSize):

                # Skip unassigned area
                if self.gridMatrix[prevY][prevX] == None:
                    continue
                
                # Calculate corresponding coordiantes in landscapeMatrix
                newX, newY = prevX + xExtend, prevY + yExtend                                 

                # Check neighbour cell below, if it belongs to a different plot of land then add road
                if prevY < self.ySize-1 and self.gridMatrix[prevY][prevX] != self.gridMatrix[prevY+1][prevX]:

                    # Extend length of landscape matrix if not already extended
                    if not yBuffer[prevY]:
                        self.landscapeMatrix.insert(
                            newY+1, [
                                self.landscapeMatrix[newY][x] if self.landscapeMatrix[newY][x] == self.landscapeMatrix[newY+1][x]
                                else None 
                                for x in range(self.xSize + xExtend)]
                        )
                        yBuffer[prevY] = True
                        yExtend += 1

        # # Uncomment to see the results of vertical extension
        # for i in range(len(self.landscapeMatrix)):
        #     print(self.landscapeMatrix[i])
        # print()

        # Update actual map size
        self.xSize += xExtend
        self.ySize += yExtend

        # Pad landscape for land plot reconstruction and road fitting
        self.landscapeMatrix = (
            [[None for i in range(self.xSize + 2)]] + 
            [[None] + self.landscapeMatrix[i] + [None] for i in range(self.ySize)] +
            [[None for i in range(self.xSize + 2)]]
        )
        
        # Reconstruct all land plots
        for yPos in range(1, self.ySize + 1):
            for xPos in range(1, self.xSize + 1):

                # Skip unassigned area
                if self.landscapeMatrix[yPos][xPos] == None:
                    continue

                landPlotID = self.landscapeMatrix[yPos][xPos]

                # If the current cell is the bottom left corner, create new land plot
                if landPlotID != self.landscapeMatrix[yPos][xPos-1] and landPlotID != self.landscapeMatrix[yPos-1][xPos]:

                    # Initiate size variables of the land plot
                    xSize, ySize = 0, 0
                    
                    for xCoord in range(xPos, self.xSize + 1):
                        if self.landscapeMatrix[yPos][xCoord] == landPlotID:
                            xSize += 1

                    for yCoord in range(yPos, self.ySize + 1):
                        if self.landscapeMatrix[yCoord][xPos] == landPlotID:
                            ySize += 1

                    # Create land plot
                    landPlot = LandPlot(xSize, ySize)
                    landPlot.set_coordinate(xPos, yPos)
                    self.landPlots.append(landPlot)

                    # Add land plot to component references
                    for yCoord in range(yPos, yPos + ySize):
                        for xCoord in range(xPos, xPos + xSize):                            
                            self.landMap[(yCoord, xCoord)] = landPlot

        # Create roads and intersections
        for landPlot in self.landPlots:

            # Spawn intersections at all four corners of every land plot
            corners = [
                (landPlot.xPos-1, landPlot.yPos-1), 
                (landPlot.xPos + landPlot.xSize, landPlot.yPos-1),
                (landPlot.xPos-1, landPlot.yPos + landPlot.ySize),
                (landPlot.xPos + landPlot.xSize, landPlot.yPos + landPlot.ySize)
            ]
            bottomLeft, bottomRight, topLeft, topRight = [Intersection(*corner) for corner in corners]

            # Register intersections
            for possible_intersection in [bottomLeft, bottomRight, topLeft, topRight]:
                self.intersections[possible_intersection.coordinates()] = possible_intersection

            # Label intersections and roads
            self.label_intersections(bottomLeft.coordinates(), bottomRight.coordinates())
            self.label_intersections(bottomLeft.coordinates(), topLeft.coordinates())
            self.label_intersections(topRight.coordinates(), bottomRight.coordinates())
            self.label_intersections(topRight.coordinates(), topLeft.coordinates())

            # Update land plot labels
            for yCoord in range(landPlot.yPos, landPlot.yPos + landPlot.ySize):
                for xCoord in range(landPlot.xPos, landPlot.xPos + landPlot.xSize):
                    self.landscapeMatrix[yCoord][xCoord] = "LP"

        # # Unpad landscape to remove the artificialroad perimeter
        # self.landscapeMatrix = [self.landscapeMatrix[i][1:self.xSize+1] for i in range(1, self.ySize+1)]

        # Fill unassigned area with land plots
        for yCoord in range(self.ySize + 2):
            for xCoord in range(self.xSize + 2):
                if self.landscapeMatrix[yCoord][xCoord] == None:
                    self.landscapeMatrix[yCoord][xCoord] = "LP"
                    # NOTE: land plots added here are NOT registered within self.landPlots or self.landMap

        # Connect intersections via DFS and create road objects for graph
        stack = []
        visited = set()

        for intersection_pos in self.intersections.keys(): # start with a random intersection
            stack.append(intersection_pos)
            break

        while stack:
            xPos, yPos = stack.pop()
            if (xPos, yPos) in visited:
                continue
            visited.add((xPos, yPos))

            for xCoord in range(xPos+1, self.xSize+2): # search for east neighbour
                if self.landscapeMatrix[yPos][xCoord] == "IS":
                    self.connect_intersections(self.intersections[(xPos, yPos)], self.intersections[(xCoord, yPos)])
                    stack.append((xCoord, yPos))
                    break
                elif self.landscapeMatrix[yPos][xCoord] == "LP":
                    break

            for xCoord in range(xPos-1, -1, -1): # search for west neighbour
                if self.landscapeMatrix[yPos][xCoord] == "IS":
                    self.connect_intersections(self.intersections[(xPos, yPos)], self.intersections[(xCoord, yPos)])
                    stack.append((xCoord, yPos))
                    break
                elif self.landscapeMatrix[yPos][xCoord] == "LP":
                    break

            for yCoord in range(yPos+1, self.ySize+2): # search for north neighbour
                if self.landscapeMatrix[yCoord][xPos] == "IS":
                    self.connect_intersections(self.intersections[(xPos, yPos)], self.intersections[(xPos, yCoord)])
                    stack.append((xPos, yCoord))
                    break
                elif self.landscapeMatrix[yCoord][xPos] == "LP":
                    break

            for yCoord in range(yPos-1, -1, -1): # search for south neighbour
                if self.landscapeMatrix[yCoord][xPos] == "IS":
                    self.connect_intersections(self.intersections[(xPos, yPos)], self.intersections[(xPos, yCoord)])
                    stack.append((xPos, yCoord))
                    break
                elif self.landscapeMatrix[yCoord][xPos] == "LP":
                    break